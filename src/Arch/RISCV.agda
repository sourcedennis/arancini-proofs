{-# OPTIONS --safe #-}

module Arch.RISCV where

-- Stdlib imports
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl) renaming (sym to ≡-sym)
open import Data.Product using (_,_; ∃-syntax)
open import Data.Sum using (inj₁; inj₂)
open import Data.Bool using (Bool)
open import Function using (_∘_; flip)
open import Relation.Nullary using (¬_; yes; no)
open import Relation.Unary using (Pred; Empty)
open import Relation.Binary using (Rel; Irreflexive)
open import Relation.Binary.Construct.Closure.Transitive using (TransClosure; [_]; _∷_)
-- Local library imports
open import Dodo.Nullary
open import Dodo.Unary
open import Dodo.Binary
open import Burrow.Template.Arch as Π
-- Local imports
open import Helpers


open Tag

-- | RISC-V LD/SC and AMO instructions have 2 bits: "acq" and "rel".
-- (See RISC-V manual sec 8.2 and 8.4)
record Ann : Set where
  constructor _⦂ann⦂_
  field
    acq rel : Bool

open Bool

pattern ann-none   = false ⦂ann⦂ false
pattern ann-acq    = true  ⦂ann⦂ false
pattern ann-rel    = false ⦂ann⦂ true
pattern ann-acqrel = true  ⦂ann⦂ true


data LabR : Set where
  -- | Read event
  --
  -- The tag indicates which instruction generated the event.
  -- * `tmov` - Either a regular load or a LR (Load Reserved) instruction.
  --     We don't distinguish between regular LOADs and LRs *without*
  --     acq/rel annotations (i.e., `ann-no`).
  -- * `trmw` - Load event, as generated by an AMO instruction
  --
  -- The annotation (`Ann`) indicates which acq/rel flags were set on its
  -- instruction. (See `Ann`)
  lab-r  : Tag → Ann → LabR


data LabW : Set where
  -- | Write event
  --
  -- The tag indicates which instruction generated the event.
  -- * `tmov` - Either a regular write or a SC (Store Conditional) instruction.
  --     We don't distinguish between regular STOREs and SCs *without*
  --     acq/rel annotations (i.e., `ann-no`).
  -- * `trmw` - Store event, as generated by an AMO instruction
  --
  -- The annotation (`Ann`) indicates which acq/rel flags were set on its
  -- instruction. (See `Ann`)
  lab-w  : Tag → Ann → LabW


-- | Classifier for memory accesses. Used in `LabF`.
data AccessClass : Set where
  𝐴R : AccessClass -- read
  𝐴W : AccessClass -- write
  𝐴M : AccessClass -- memory (read / write)


data LabF : Set where
  -- | Orders two classes of accesses
  --
  -- Example:
  -- > 𝐴R 𝐹 𝐴W
  -- represents a fence ordering *preceding reads* with *subsequent writes*.
  _𝐹_ : AccessClass → AccessClass → LabF

  TSO : LabF -- orders W×W and R×M pairs


-- # Lemmas/Properties

lab-r-tag : LabR → Tag
lab-r-tag (lab-r tag _) = tag

lab-w-tag : LabW → Tag
lab-w-tag (lab-w tag _) = tag

bool-dec≡ : Dec≡ Bool
bool-dec≡ false false = yes refl
bool-dec≡ true  true  = yes refl
bool-dec≡ false true  = no (λ ())
bool-dec≡ true  false = no (λ ())

ann-dec≡ : Dec≡ Ann
ann-dec≡ (acq₁ ⦂ann⦂ rel₁) (acq₂ ⦂ann⦂ rel₂) =
  cong₂-dec _⦂ann⦂_
    (λ{refl → refl}) (λ{refl → refl})
    (bool-dec≡ acq₁ acq₂) (bool-dec≡ rel₁ rel₂)

lab-r-dec≡ : Dec≡ LabR
lab-r-dec≡ (lab-r tag₁ ann₁) (lab-r tag₂ ann₂) =
  cong₂-dec lab-r
    (λ{refl → refl}) (λ{refl → refl})
    (tag-dec≡ tag₁ tag₂) (ann-dec≡ ann₁ ann₂)

lab-w-dec≡ : Dec≡ LabW
lab-w-dec≡ (lab-w tag₁ ann₁) (lab-w tag₂ ann₂) =
  cong₂-dec lab-w
    (λ{refl → refl}) (λ{refl → refl})
    (tag-dec≡ tag₁ tag₂) (ann-dec≡ ann₁ ann₂)
    
access-class-dec≡ : Dec≡ AccessClass
access-class-dec≡ 𝐴R 𝐴R = yes refl
access-class-dec≡ 𝐴W 𝐴W = yes refl
access-class-dec≡ 𝐴M 𝐴M = yes refl
access-class-dec≡ 𝐴R 𝐴W = no (λ())
access-class-dec≡ 𝐴R 𝐴M = no (λ())
access-class-dec≡ 𝐴W 𝐴R = no (λ())
access-class-dec≡ 𝐴W 𝐴M = no (λ())
access-class-dec≡ 𝐴M 𝐴R = no (λ())
access-class-dec≡ 𝐴M 𝐴W = no (λ())

lab-f-dec≡ : Dec≡ LabF
lab-f-dec≡ (l₁ 𝐹 r₁) (l₂ 𝐹 r₂) =
  cong₂-dec _𝐹_
    (λ{refl → refl}) (λ{refl → refl})
    (access-class-dec≡ l₁ l₂) (access-class-dec≡ r₁ r₂)
lab-f-dec≡ TSO       TSO = yes refl
lab-f-dec≡ TSO       (_ 𝐹 _) = no (λ())
lab-f-dec≡ (_ 𝐹 _)   TSO     = no (λ())


arch-RISCV : Arch
arch-RISCV =
  record
    { LabR       = LabR
    ; LabW       = LabW
    ; LabF       = LabF
    ; lab-r-tag  = lab-r-tag
    ; lab-w-tag  = lab-w-tag
    ; lab-r-dec≡ = lab-r-dec≡
    ; lab-w-dec≡ = lab-w-dec≡
    ; lab-f-dec≡ = lab-f-dec≡
    }


pattern RR = 𝐴R 𝐹 𝐴R
pattern RW = 𝐴R 𝐹 𝐴W
pattern RM = 𝐴R 𝐹 𝐴M
pattern WR = 𝐴W 𝐹 𝐴R
pattern WW = 𝐴W 𝐹 𝐴W
pattern WM = 𝐴W 𝐹 𝐴M
pattern MR = 𝐴M 𝐹 𝐴R
pattern MW = 𝐴M 𝐹 𝐴W
pattern MM = 𝐴M 𝐹 𝐴M


open Π.Ev arch-RISCV

EventRISCV = Event -- parameterized over `arch-RISCV`


record RISCVExecution : Set₁ where
  field
    data₋ : Rel₀ Event -- called `data₋`, because `data` is a keyword
    addr  : Rel₀ Event
    ctrl  : Rel₀ Event


module Relations (ex : Execution {arch-RISCV}) (rex : RISCVExecution) where

  open Π.Defs ex
  open RISCVExecution rex

  open import Data.Sum using (_⊎_)

  -- | Reflexive closure of R
  ReflRel : Rel₀ Event → Rel₀ Event
  ReflRel R = R ∪₂ _≡_


  po-loc-no-w : Rel₀ Event
  po-loc-no-w = po-loc \₂ (ReflRel po-loc ⨾ ⦗ EvW ⦘ ⨾ po-loc)

  rsw : Rel₀ Event
  rsw = flip rf ⨾ rf

  -- | Fence ordered before
  data Fob (x y : Event) : Set where
    fob-rr : ( ⦗ EvR ⦘  ⨾ po ⨾ ⦗ EvFₜ RR ⦘ ⨾ po ⨾ ⦗ EvR ⦘ )  x y → Fob x y
    fob-rw : ( ⦗ EvR ⦘  ⨾ po ⨾ ⦗ EvFₜ RW ⦘ ⨾ po ⨾ ⦗ EvW ⦘ )  x y → Fob x y
    fob-rm : ( ⦗ EvR ⦘  ⨾ po ⨾ ⦗ EvFₜ RM ⦘ ⨾ po ⨾ ⦗ EvRW ⦘ ) x y → Fob x y

    fob-wr : ( ⦗ EvW ⦘  ⨾ po ⨾ ⦗ EvFₜ WR ⦘ ⨾ po ⨾ ⦗ EvR ⦘ )  x y → Fob x y
    fob-ww : ( ⦗ EvW ⦘  ⨾ po ⨾ ⦗ EvFₜ WW ⦘ ⨾ po ⨾ ⦗ EvW ⦘ )  x y → Fob x y
    fob-wm : ( ⦗ EvW ⦘  ⨾ po ⨾ ⦗ EvFₜ WM ⦘ ⨾ po ⨾ ⦗ EvRW ⦘ ) x y → Fob x y

    fob-mr : ( ⦗ EvRW ⦘ ⨾ po ⨾ ⦗ EvFₜ MR ⦘ ⨾ po ⨾ ⦗ EvR ⦘ )  x y → Fob x y
    fob-mw : ( ⦗ EvRW ⦘ ⨾ po ⨾ ⦗ EvFₜ MW ⦘ ⨾ po ⨾ ⦗ EvW ⦘ )  x y → Fob x y
    fob-mm : ( ⦗ EvRW ⦘ ⨾ po ⨾ ⦗ EvFₜ MM ⦘ ⨾ po ⨾ ⦗ EvRW ⦘ ) x y → Fob x y

    fob-tso₁ : ( ⦗ EvW ⦘ ⨾ po ⨾ ⦗ EvFₜ TSO ⦘ ⨾ po ⨾ ⦗ EvW ⦘ )  x y → Fob x y
    fob-tso₂ : ( ⦗ EvR ⦘ ⨾ po ⨾ ⦗ EvFₜ TSO ⦘ ⨾ po ⨾ ⦗ EvRW ⦘ ) x y → Fob x y

  private
    variable
      uid : UniqueId
      tid : ThreadId
      loc : Location
      val : Value
      tag : Tag


  -- | Predicate stating the event has an acquire annotation
  data EvAcq : Pred₀ Event where
    ev-acq-r : {rel : Bool} → EvAcq (event-r uid tid loc val (lab-r tag (true ⦂ann⦂ rel)))
    ev-acq-w : {rel : Bool} → EvAcq (event-w uid tid loc val (lab-w tag (true ⦂ann⦂ rel)))

  -- | Predicate stating the event has an release annotation
  data EvRel : Pred₀ Event where
    ev-rel-r : {acq : Bool} → EvRel (event-r uid tid loc val (lab-r tag (acq ⦂ann⦂ true)))
    ev-rel-w : {acq : Bool} → EvRel (event-w uid tid loc val (lab-w tag (acq ⦂ann⦂ true)))

  -- | Predicate stating the event has both acquire and release annotations
  data EvSc : Pred₀ Event where
    ev-acqrel-r : EvSc (event-r uid tid loc val (lab-r tag ann-acqrel))
    ev-acqrel-w : EvSc (event-w uid tid loc val (lab-w tag ann-acqrel))

  -- From "Preserved Program Order" in RISC-V manual section 14.1
  data Ppo (x y : Event) : Set where
    ppo₁  : ( ⦗ EvRW ⦘ ⨾ po-loc ⨾ ⦗ EvW ⦘ )                x y → Ppo x y
    ppo₂  : ( ( ⦗ EvR ⦘ ⨾ po-loc-no-w ⨾ ⦗ EvR ⦘ ) \₂ rsw ) x y → Ppo x y
    -- From manual:
    -- > "a is generated by an AMO or SC instruction, b is a load, and b returns a value written by a"
    ppo₃  : ( ⦗ EvWₜ trmw ∪₁ EvSc ⦘ ⨾ rfi ⨾ ⦗ EvR ⦘ ) x y → Ppo x y
    -- # Explicit Synchronization
    ppo₄  : Fob                                              x y → Ppo x y
    ppo₅  : ( ⦗ EvAcq ⦘ ⨾ po ⨾ ⦗ EvRW ⦘ )                    x y → Ppo x y
    ppo₆  : ( ⦗ EvRW ⦘ ⨾ po ⨾ ⦗ EvRel ⦘ )                    x y → Ppo x y
    ppo₇  : ( ⦗ EvAcq ∪₁ EvRel ⦘ ⨾ po ⨾ ⦗ EvAcq ∪₁ EvRel ⦘ ) x y → Ppo x y
    ppo₈  : rmw                                              x y → Ppo x y
    -- # Syntactic Dependencies
    ppo₉  : addr               x y → Ppo x y
    ppo₁₀ : data₋              x y → Ppo x y
    ppo₁₁ : ( ctrl ⨾ ⦗ EvW ⦘ ) x y → Ppo x y
    -- # Pipeline Dependencies
    ppo₁₂ : ( ( addr ∪₂ data₋ ) ⨾ rfi ⨾ ⦗ EvR ⦘ ) x y → Ppo x y
    ppo₁₃ : ( addr ⨾ po ⨾ ⦗ EvW ⦘ )               x y → Ppo x y


  record IsRISCVConsistent : Set where
    field
      data-def₁ : data₋ ⊆₂ EvR ×₂ EvW
      data-def₂ : data₋ ⊆₂ po
      addr-def₁ : addr  ⊆₂ EvR ×₂ ( EvR ∪₁ EvW )
      addr-def₂ : data₋ ⊆₂ po
      ctrl-def₁ : ctrl  ⊆₂ EvR ×₂ EvE
      ctrl-def₂ : ctrl  ⊆₂ po
      ctrl-def₃ : ( ctrl ⨾ po ) ⊆₂ ctrl

      -- # Armv8-specific consistency constraints

      ax-coherence : Acyclic _≡_ ( co ∪₂ rf ∪₂ fr ∪₂ po-loc ) -- "Internal Visibility"
      ax-model     : Acyclic _≡_ ( co ∪₂ rfe ∪₂ fr ∪₂ Ppo )
      ax-atomicity : Empty₂ ( rmw ∩₂ (fre ⨾ coe) )
